/*
 Software for simple Drawdio inspired AVR synth (/w ATtiny85).
 Copyright (C) 2013  Jari Suominen
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <EEPROM.h>

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

#define PENCIL_CAP 4
#define PENCIL_DRIVER 3
#define SPEAKER 0

#define MODE_NORMAL 0
#define MODE_TILU 1
#define MODE_ARP 2
#define MODE_SH 3
#define MODE_COUNT 4

#define ARP_SPEED 200

boolean output = false;
int mode = MODE_SH;

void setup(){

  /* We are selecting iterating through
   preselected modes every time when
   pencil is switched on. */
  mode = EEPROM.read(0);
  mode++;
  mode %= MODE_COUNT;
  EEPROM.write(0,mode);

  pinMode(SPEAKER,OUTPUT);
  pinMode(PENCIL_CAP,INPUT);
  pinMode(PENCIL_DRIVER,OUTPUT);

  sbi(GIMSK,PCIE);   // Turn on Pin Change interrupt
  sbi(PCMSK,PCINT4); // Which pins are affected by the interrupt

  /* Lets make sure that cap charching/discharging process kicks on. */
  digitalWrite(PENCIL_DRIVER,!digitalRead(PENCIL_CAP));

  initMode(mode);
}

/*
  Some modes will use frequency generated by RC network as it is,
 while others will use frequency as sequencer tempo.
 */
void initMode(int m) {
  switch (m) {
  case MODE_SH:
    initCTC();
    break; 
  case MODE_NORMAL:
  case MODE_TILU:
  case MODE_ARP:
    TCCR0A = B00000000; // disconnecting CTC mode
    break;
  }
}

void initCTC() {
  pinMode(0,OUTPUT);
  TCCR0B = B00000011; // prescaler 64
  TCCR0A = B01000010; // CTC mode
  OCR0A=B11111111;
}

void loop(){
  /* Not doing much in here! */
}

/*
  Pin change interupt used for measuring resistance
 of RC network.
 */
boolean octaveDown = false;
long ticker = 0;
int arp_counter = 0;
ISR(PCINT0_vect) {
  ticker++;

  /* These lines take care of charging and
   recharging the pencil cap. Effectively this will
   emulate 555 based drawdio as accurately as possible.
   */
  if ((PINB & B00010000) == B00010000) {
    /*
    Pencil cap was high, we will start to uncharge it by
     setting driver pin low.
     */
    DDRB = B11101111;
    PORTB = PORTB & B11110111;
  } 
  else {
    /*
    Pencil cap was low, we will start to charge it through
     built in 20k pull up resistor (simply connecting pin
     to Vcc would charge cap too fast, so we will use 20k
     pullup (drawdio uses 10k resistor here)).
     */
    DDRB = B11100111;
    PINB = B00001000;
  }

  /*
    Audio synthesis part.
   */
  switch (mode) {
  case MODE_NORMAL:
    // typical drawdio mode
    PINB = B00000001;
    break;
  case MODE_TILU: 
    // we will toggle sound one octave up and down.
    {
      if (!octaveDown || ticker%2==0) {
        PINB = B00000001;
      }
      if (ticker > 200) {
        ticker = 0;
        octaveDown = !octaveDown;  
      }
      break;
    }
  case MODE_ARP:
    // 20 not arpeggio downwards.
    {
      if (ticker%arp_counter==0) {
        PINB = B00000001;
      }
      if (ticker > 200) {
        ticker = 0;
        octaveDown = !octaveDown;  
        arp_counter++;
        arp_counter%=20;
      }
      break; 
    }
  case MODE_SH:
    // sample & hold
    if (ticker > ARP_SPEED) {
      ticker = 0;
      OCR0A = random(254)+1;  
    }
    break;
  default:
    break;
  }
}







